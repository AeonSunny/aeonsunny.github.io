[{"title":"Hello World","url":"/2025/08/07/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"godot子弹","url":"/2025/08/30/godot%E5%AD%90%E5%BC%B9/","content":"一.RigidBody2D如果您希望玩家角色本身就是枪，那么整个逻辑会变得更简单、更直接。您不需要独立的枪节点，可以直接在玩家脚本中处理子弹的生成和发射。\n\n1. 准备子弹场景这一步和之前一样。您仍然需要一个子弹场景 (.tscn 文件)，它的根节点是 RigidBody3D (3D) 或 RigidBody2D (2D)，并附加一个脚本来控制它的移动和销毁。\n# bullet.gdextends RigidBody3D@export var speed = 20.0@export var life_time = 3.0func _ready():    var timer = get_tree().create_timer(life_time)    timer.timeout.connect(self.queue_free)func _physics_process(delta):    # 子弹沿其局部坐标系的 Z 轴前进    linear_velocity = -transform.basis.z * speed\n\n\n2. 在玩家脚本中处理发射逻辑现在，所有的发射代码都将集成到玩家角色的脚本中。\n# player.gdextends CharacterBody3D # 或者 CharacterBody2D# 预加载子弹场景@export var bullet_scene: PackedScene# 发射子弹的冷却时间，单位为秒@export var fire_rate = 0.2var can_shoot = truefunc _input(event):    # 当按下 &quot;shoot&quot; 动作且可以射击时    if event.is_action_pressed(&quot;shoot&quot;) and can_shoot:        shoot()        can_shoot = false                # 使用定时器来控制射击冷却        var timer = get_tree().create_timer(fire_rate)        timer.timeout.connect(func(): can_shoot = true)# 发射子弹的函数func shoot():    # 实例化一个子弹    var bullet = bullet_scene.instantiate()        # 将子弹的全局位置和旋转设置为玩家的位置和旋转    bullet.global_transform = self.global_transform        # 将子弹添加到场景树中    get_tree().root.add_child(bullet)\n\n总结这种方法将玩家和“枪”的功能合并成一个实体，让代码更集中，特别适合第一人称射击游戏（FPS）或一些简单的自上而下射击游戏。\n\n子弹场景：依然是独立的，负责自身的移动和生命周期。\n玩家脚本：直接实例化子弹，并设置子弹的初始位置和方向与玩家一致。\n冷却时间：通过一个简单的计时器，您可以轻松控制子弹的发射频率，避免玩家一次性发射过多子弹。\n\n这种实现方式更简洁、高效，因为您省去了处理额外节点层级（比如枪节点和发射点）的麻烦。\n二.Area2DGodot 4.4.1: 让玩家化身“神枪手”——使用Area2D实现内置射击功能在Godot 4.4.1中，将玩家角色自身设计为“枪”是一种新颖且高效的机制，尤其适用于快节奏的射击游戏或需要精确碰撞检测的场景。通过巧妙运用Area2D节点，我们可以轻松实现这一功能，无论是发射独立的子弹，还是让玩家自身产生一个瞬时的“攻击范围”。\n本文将详细介绍两种核心实现方法：\n\n玩家作为发射器: 从玩家位置实例化并发射独立的“子弹”场景。\n玩家即武器: 直接利用玩家自身的Area2D节点来检测攻击命中。\n\n准备工作：创建玩家和“子弹”场景在开始之前，请确保你已经有一个基本的玩家场景。通常，这个场景会包含一个CharacterBody2D作为根节点，并附带一个Sprite2D（或AnimatedSprite2D）和CollisionShape2D。\n1. 设置子弹场景 (如果选择方法一)如果希望玩家发射可见的飞行道具，首先需要创建一个“子弹”场景。\n\n节点结构:\n\nArea2D (命名为 Bullet)\nSprite2D (用于显示子弹外观)\nCollisionShape2D (定义子弹的碰撞范围)\nVisibleOnScreenNotifier2D (可选，用于在子弹离开屏幕时销毁，优化性能)\n\n\n\n\n为子弹添加脚本 (bullet.gd):附加一个脚本到Bullet根节点，用于控制其移动和碰撞逻辑。\nextends Area2Dvar speed = 800var direction = Vector2.RIGHT # 默认向右func _physics_process(delta):    # 沿指定方向移动    global_position += direction * speed * delta# 连接Area2D的body_entered信号func _on_body_entered(body):    # 检查是否击中敌人或障碍物    if body.is_in_group(&quot;enemies&quot;):        body.queue_free() # 销毁敌人    queue_free() # 销毁子弹自身# (可选) 连接VisibleOnScreenNotifier2D的screen_exited信号func _on_visible_on_screen_notifier_2d_screen_exited():    queue_free()\n\n信号连接: 在Godot编辑器中，选中Bullet节点的Node面板，将body_entered信号连接到_on_body_entered函数。如果使用了VisibleOnScreenNotifier2D，也同样连接其screen_exited信号。\n\n\n\n方法一：玩家作为发射器这种方法最为常见，玩家角色将作为“子弹”场景的生成点和发射方向的来源。\n1. 完善玩家节点结构在你的玩家场景中，添加一个Marker2D节点，并将其命名为Muzzle（枪口）。将这个节点放置在你希望子弹生成的位置，例如玩家精灵的前方。\n\n玩家场景结构:\nCharacterBody2D (Player)\nSprite2D\nCollisionShape2D\nMuzzle (Marker2D)\n\n\n\n\n\n2. 编写玩家射击脚本在玩家的脚本中，我们需要加载子弹场景，并在玩家输入时实例化它。\n# player.gdextends CharacterBody2D# 预加载子弹场景const BULLET_SCENE = preload(&quot;res://bullet.tscn&quot;)@onready var muzzle = $Muzzlefunc _unhandled_input(event):    # 当按下&quot;shoot&quot;输入动作时    if event.is_action_pressed(&quot;shoot&quot;):        shoot()func shoot():    # 实例化子弹    var bullet_instance = BULLET_SCENE.instantiate()    # 设置子弹的初始位置和方向    # 使用muzzle的全局位置和旋转，确保子弹在世界空间中正确定位    bullet_instance.global_transform = muzzle.global_transform    # 为了避免子弹跟随玩家移动，必须将其添加到主场景树中    # get_tree().root.add_child(bullet_instance) 是一种方法，但更好的方法是让关卡场景来管理    get_parent().add_child(bullet_instance)\n\n关键点:\n\npreload: 提前加载子弹场景以获得更好的性能。\ninstantiate(): 创建子弹场景的一个新实例。\nglobal_transform: 将Muzzle节点的全局位置、旋转和缩放信息直接赋给子弹实例，可以确保子弹在发射时朝向正确的方向。\nget_parent().add_child(): 这是至关重要的一步。如果直接add_child(bullet_instance)，子弹会成为玩家的子节点，并跟随玩家移动。将其添加到玩家的父节点（通常是主关卡场景）可以使其独立运动。\n\n输入映射: 别忘了在 项目 -&gt; 项目设置 -&gt; 输入映射 中添加一个名为 shoot 的输入动作，并为其绑定一个按键（例如鼠标左键或空格键）。\n\n方法二：玩家即武器 (瞬时攻击范围)这种方法更适合近战攻击或者范围效果，玩家的Area2D会暂时启用，检测范围内的敌人。\n1. 设置玩家的攻击Area2D在玩家场景中，直接添加一个Area2D节点，并为其配置碰撞形状。\n\n玩家场景结构:\nCharacterBody2D (Player)\nSprite2D\nCollisionShape2D (用于物理碰撞)\nAttackArea (Area2D)\nAttackCollisionShape (CollisionShape2D)\n\n\n\n\n\n\n\n将AttackCollisionShape的形状调整为你希望的攻击范围，例如玩家前方的一个矩形或圆形。在默认情况下，可以禁用这个碰撞形状，只在攻击时启用。\n2. 编写攻击逻辑脚本在玩家脚本中，我们将通过代码来控制AttackArea的碰撞检测。\n# player.gdextends CharacterBody2D@onready var attack_area = $AttackArea@onready var attack_collision_shape = $AttackArea/AttackCollisionShapefunc _ready():    # 默认禁用攻击范围，避免持续检测    attack_collision_shape.disabled = truefunc _unhandled_input(event):    if event.is_action_pressed(&quot;shoot&quot;):        attack()func attack():    # 启用碰撞形状    attack_collision_shape.disabled = false    # 获取当前重叠的物体    var overlapping_bodies = attack_area.get_overlapping_bodies()    for body in overlapping_bodies:        if body.is_in_group(&quot;enemies&quot;):            print(&quot;击中敌人: &quot;, body.name)            body.queue_free() # 或者调用一个 take_damage() 方法    # 为了让攻击效果是瞬时的，在一帧之后或短暂延迟后禁用碰撞形状    # 使用 await 创建一个短暂的计时器    await get_tree().create_timer(0.1).timeout    attack_collision_shape.disabled = true\n\n关键点:\n\n动态启用&#x2F;禁用: 通过控制CollisionShape2D的disabled属性，我们可以在需要时才进行碰撞检测，极大地提升了性能。\nget_overlapping_bodies(): Area2D的核心功能之一，可以立即获取当前正与其重叠的所有PhysicsBody2D（如CharacterBody2D, RigidBody2D）节点的列表。\nawait get_tree().create_timer(): 这是一个在GDScript中创建延迟的便捷方法。我们利用它来确保攻击判定只在攻击发生的瞬间有效，而不是一个持续的状态。\n\n总结与选择\n\n\n特性\n方法一：玩家作为发射器\n方法二：玩家即武器\n\n\n\n适用场景\n远程攻击、需要飞行时间的子弹、弹幕游戏\n近战攻击、光束武器、冲击波、即时命中（Hitscan）\n\n\n视觉表现\n子弹是独立的、可见的实体\n攻击效果通常通过动画或粒子效果表现\n\n\n性能开销\n实例化大量子弹可能会有性能开销\n开销极低，因为没有创建新节点\n\n\n实现复杂度\n需要管理独立的子弹场景\n逻辑集中在玩家脚本中，相对简单\n\n\n选择哪种方法取决于你的游戏设计。对于传统的射击游戏，方法一是标准且灵活的选择。而对于动作游戏中的剑砍、拳击，或是科幻游戏中的短程能量爆发，方法二则更加高效和直接。你甚至可以在一个玩家身上结合这两种方法，实现多样化的攻击模式。\n"},{"url":"/2025/09/21/new/","content":"1 2 3,5,71 3 4,5,7,81 4 5,71 5 6,7,81 6 71 7 8\n2 3 5,72 4 5,72 5 72 6 72 7 8\n3 4 5,73 5 7,83 7 8\n4 5 6,74 6 7\n4 7 8\n"}]